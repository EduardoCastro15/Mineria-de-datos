# -*- coding: utf-8 -*-
"""5 - ReglasAsociacion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CYw_rRQTrW_N8DK48S1wRCezq3ZXX3g8

***Carga de las bibliotecas***
"""

import warnings
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from pandas.plotting import parallel_coordinates
from mlxtend.preprocessing import TransactionEncoder
from mlxtend.frequent_patterns import apriori, association_rules
warnings.filterwarnings('ignore')

"""***Carga del dataset***"""

df = pd.read_csv('/content/drive/MyDrive/ESCOM/8vo Semestre/Data Mining/Extraordinario/basket_analysis.csv')
df.drop(df.columns[0],axis=1,inplace=True)

"""***Análisis del dataset***"""

df.shape

"""Tenemos 999 canastas para calcular la recomendación de cada artículo que se vende en la tienda. Hay 16 artículos vendidos en la tienda."""

df.mean()

"""La transacción de venta o el recuento de cada artículo único aproximadamente para esta muestra. Nos sumergiremos y veremos si hay alguna diferencia o correlación entre las canastas. Dado que el marco de datos ya está tabulado como un marco de datos activo, de inmediato usaremos el conjunto de datos que se analizará con apriori.

***Algoritmo APRIORI***

Breve introducción a los antecedentes del algoritmo Apriori. El algoritmo asume que cualquier subconjunto de un conjunto de elementos frecuentes debe ser frecuente. Digamos que en nuestros casos, donde {manzana, unicornio, yogur} es frecuente, entonces {manzana, yogur} es frecuente. Mientras que {manzana, unicornio} no es frecuente, entonces {manzana, unicornio, yogur} no es frecuente.

*  APOYO = Una forma simple de controlar la complejidad es imponer una restricción que dichas reglas deben aplicar a un porcentaje mínimo de los datos.
CONFIANZA = La probabilidad de que B ocurra cuando A; es p (B | A), que en asociación minera.
*   LIFT = la co-ocurrencia de A y B es la probabilidad de que realmente veamos los dos juntos, en comparación con la probabilidad de que los veamos juntos si no estuvieran relacionados (independientes) entre sí.
*   APALANCAMIENTO = alternativa es mirar la diferencia entre estas cantidades en lugar de su relación.
*   CONVICCIÓN = medida para determinar la dirección de la regla. A diferencia de la elevación, la convicción es sensible a la dirección de la regla.

Solo el apoyo y la confianza como parámetro pueden ser engañosos para los artículos que son demasiado comunes / populares en la canasta. Es más probable que los artículos populares formen parte de la misma canasta solo porque son populares en lugar de cualquier otra cosa.

Establecemos el soporte mínimo en 0.06, el número máximo que se analiza en la canasta es 3. Estamos haciendo la primera poda y vemos qué obtenemos del resultado

***Calculo de conjuntos de elementos frecuentes utilizando el algoritmo Apriori***
"""

frequent_itemsets = apriori(df,
                            min_support = .006,
                            max_len = 3,
                            use_colnames = True)

"""***Calculo de todas las reglas de asociación para frecuent_itemsets***"""

rules = association_rules(frequent_itemsets,
                            metric = 'support',
                            min_threshold=0.1)

filtered_rules = rules[(rules['antecedent support'] > 0.02)&
                        (rules['consequent support'] >0.01) &
                        (rules['confidence'] > 0.2) &
                        (rules['lift'] > 1.0)]

filtered_rules.sort_values('confidence',ascending=False)

"""***Generar confianza en gráficos de dispersión frente a soporte***"""

sns.scatterplot(x = "support", y = "confidence", data = filtered_rules)
plt.show()

"""Con el diagrama de dispersión, podemos echar un vistazo rápido, dónde debería estar el límite y qué métrica debería establecerse para filtrar los conjuntos de elementos frecuentes."""

filtered_rules = rules[(rules['antecedent support'] > 0.02)&
                        (rules['consequent support'] >0.01) &
                        (rules['confidence'] > 0.45) &
                        (rules['lift'] > 1.0)]

"""***Generar confianza en gráficos de dispersión frente a soporte***"""

sns.scatterplot(x = "support", y = "confidence", size= 'leverage',data = filtered_rules)
plt.legend(bbox_to_anchor= (1.02, 1), loc='upper left',)
plt.show()

"""***Agregar texto en negrita otra regla adicional donde admita más de 0.2 para un conjunto de elementos dado***"""

filtered_rules = rules[(rules['antecedent support'] > 0.02)&
                        (rules['consequent support'] >0.01) &
                        (rules['confidence'] > 0.45) &
                        (rules['lift'] > 1.0)&
                        (rules['support']>0.195)]
filtered_rules

def rules_to_coordinates(rules):
    rules['antecedent'] = rules['antecedents'].apply(lambda antecedent:list(antecedent)[0])
    rules['consequent'] = rules['consequents'].apply(lambda consequent:list(consequent)[0])
    rules['rule'] = rules.index
    return rules[['antecedent','consequent','rule']]

"""***Convertir reglas en coordenadas adecuadas para su uso en una gráfica de coordenadas paralelas***"""

coords = rules_to_coordinates(filtered_rules)

"""***Generar gráfico de coordenadas paralelas***"""

plt.figure(figsize=(3,6))
parallel_coordinates(coords, 'rule',colormap = 'ocean')
plt.legend([])
plt.show()

"""Desde el gráfico parece que la mantequilla se puede usar como venta cruzada con otros productos, también actúa como algo a ofrecer con antecedentes que es bajo. Así, es más probable que los clientes las compren si la mantequilla se les ofrece a un precio más económico si compran los antecedentes que se vendieron menos en una tienda."""